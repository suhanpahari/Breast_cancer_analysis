# -*- coding: utf-8 -*-
"""ply.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1umMA2MMMbnhjKqxm2CQG4Lj7L3PWUHUL
"""

R.version.string

install.packages("BiocManager", repos = "https://cloud.r-project.org")

library("BiocManager")

install.packages("umap", version = "0.2.9.0")

install.packages("reshape2")

install.packages("pheatmap")

BiocManager::install("GEOquery", version = "3.19")

BiocManager::install("limma")

install.packages("ggplot2")
install.packages("ggrepel")

library(GEOquery)
library(limma)
library(umap)

library(GEOquery)
library(limma)
library(umap)

# load series and platform data from GEO

gset <- getGEO("GSE199135", GSEMatrix =TRUE, AnnotGPL=TRUE)
if (length(gset) > 1) idx <- grep("GPL570", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# make proper column names to match toptable
fvarLabels(gset) <- make.names(fvarLabels(gset))

# group membership for all samples
gsms <- paste0("11111111111111111111111111111111111111111111111111",
        "11111111111111111111111111111111111111111111111111",
        "111111111110")
sml <- strsplit(gsms, split="")[[1]]

# filter out excluded samples (marked as "X")
sel <- which(sml != "X")
sml <- sml[sel]
gset <- gset[ ,sel]

# log2 transformation
ex <- exprs(gset)
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
          (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
  exprs(gset) <- log2(ex) }

# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("ctrl","cncr"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)

gset <- gset[complete.cases(exprs(gset)), ] # skip missing values

fit <- lmFit(gset, design)  # fit linear model

# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups[1], groups[2], sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)

# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=250)

colnames(tT)

tT <- subset(tT, select = c("ID", "logFC", "AveExpr", "t", "P.Value", "adj.P.Val", "B", "Gene.title", "Gene.symbol", "Gene.ID", "UniGene.title", "UniGene.symbol", "UniGene.ID", "Nucleotide.Title", "GI", "GenBank.Accession", "Platform_CLONEID", "Platform_ORF", "Platform_SPOTID", "Chromosome.location", "Chromosome.annotation", "GO.Function", "GO.Process", "GO.Component", "GO.Function.ID", "GO.Process.ID", "GO.Component.ID"))
write.table(tT, file=stdout(), row.names=F, sep="\t")

tT2 <- topTable(fit2, adjust="fdr", sort.by="B", number=Inf)
hist(tT2$adj.P.Val, col = "grey", border = "white", xlab = "P-adj",
  ylab = "Number of genes", main = "P-adj value distribution")

dT <- decideTests(fit2, adjust.method="fdr", p.value=0.05, lfc=0)

vennDiagram(dT, circle.col=palette())

t.good <- which(!is.na(fit2$F)) # filter out bad probes
qqt(fit2$t[t.good], fit2$df.total[t.good], main="Moderated t statistic", cex = 1)
abline(0, 1, col="red")
grid( col = "green",lty = "dotted", )

colnames(fit2) # list contrast names
ct <- 1        # choose contrast of interest

# Ensure we have the necessary data
colnames(fit2) # list contrast names
ct <- 1        # choose contrast of interest

# Get the full results table
tT <- topTable(fit2, coef=ct, number=Inf)

# Create a custom volcanoplot function
custom_volcanoplot <- function(fit2, coef=1, main="", pch=20, highlight=0) {
  # Extract data
  p <- fit2$p.value[,coef]
  lfc <- fit2$coefficients[,coef]

  # Create the plot
  plot(lfc, -log10(p), pch=pch, main=main,
       xlab="Log2 Fold Change", ylab="-Log10 P-value")

  # Add lines for fold change cutoffs
  abline(v=c(-1, 1), col="blue", lty=2)

  # Add a line for p-value cutoff (0.05)
  abline(h=-log10(0.05), col="blue", lty=2)

  # Color points based on significance and direction
  sig_up <- p < 0.05 & lfc > 1
  sig_down <- p < 0.05 & lfc < -1

  points(lfc[sig_up], -log10(p[sig_up]), col="red", pch=20)
  points(lfc[sig_down], -log10(p[sig_down]), col="green", pch=20)

  # Add a legend
  legend("topleft", legend=c("Up in cncr", "Down in cncr", "Not significant"),
         col=c("red", "green", "black"), pch=20)

  # Mark overexpressed genes
  overexpressed <- which(p < 0.05 & lfc > 1)
  top_overexpressed <- head(overexpressed[order(-lfc[overexpressed])], 5)
  text(lfc[top_overexpressed], -log10(p[top_overexpressed]),
       labels=rownames(fit2)[top_overexpressed], pos=4, cex=0.7)
}

# Use the custom function
custom_volcanoplot(fit2, coef=ct, main=colnames(fit2)[ct],
                   highlight=length(which(tT$adj.P.Val < 0.05 & abs(tT$logFC) > 1)))

custom_volcanoplot <- function(fit2, coef=1, main="", pch=20, highlight=0) {
  # Extract data
  p <- fit2$p.value[,coef]
  lfc <- fit2$coefficients[,coef]

  # Create the plot
  plot(lfc, -log10(p), pch=pch, main=main,
       xlab="Log2 Fold Change", ylab="-Log10 P-value")

  plot(lfc, -log10(p), pch=pch, main=main,
       xlab="Log2 Fold Change", ylab="-Log10 P-value",
       xlim=c(-5, 5))

  # Add lines for fold change cutoffs
  abline(v=c(-1, 1), col="blue", lty=2)

  # Add a line for p-value cutoff (0.05)
  abline(h=-log10(0.05), col="blue", lty=2)

  # Color points based on significance and direction
  sig_up <- p < 0.05 & lfc > 1
  sig_down <- p < 0.05 & lfc < -1

  points(lfc[sig_up], -log10(p[sig_up]), col="red", pch=20)
  points(lfc[sig_down], -log10(p[sig_down]), col="green", pch=20)

  # Add a legend
  legend("topleft", legend=c("Up in cancer", "Down in cancer", "Not significant"),
         col=c("red", "green", "black"), pch=20)

  # Mark up to 30 overexpressed genes (p < 0.05 and logFC > 1)
  overexpressed <- which(sig_up)
  top_overexpressed <- head(overexpressed[order(-lfc[overexpressed])], 5)

  # Label top 30 overexpressed genes
  text(lfc[top_overexpressed], -log10(p[top_overexpressed]),
       labels=rownames(fit2)[top_overexpressed], pos=4, cex=0.7)
}

par(mar = c(5, 5, 4, 2) + 0.1, cex = 1.2)  # Increase margins and text size if needed
png("volcanoplot.png", width = 900, height = 800, res = 150)
# Use the custom function
custom_volcanoplot(fit2, coef=ct, main=colnames(fit2)[ct],
                   highlight=length(which(tT$adj.P.Val < 0.05 & abs(tT$logFC) > 1)))
dev.off()

getwd()

volcanoplot(fit2, coef=ct, main=colnames(fit2)[ct], pch=20,
  highlight=length(which(dT[,ct]!=0)), names=rep('+', nrow(fit2)))

# MD plot (log fold change vs mean log expression)
# highlight statistically significant (p-adj < 0.05) probes
plotMD(fit2, column=ct, status=dT[,ct], legend=F, pch=20, cex=1)
abline(h=0)
grid()

custom_plotMD <- function(fit2, column=1, status=NULL, legend=FALSE, pch=20, cex=1) {
  # Extract data
  avg_expr <- fit2$Amean
  lfc <- fit2$coefficients[,column]

  # Create the plot
  plot(avg_expr, lfc, pch=pch, cex=0.2,  # Smaller points for normal
       xlab="Average log-expression", ylab="Log-fold change",
       main="ctrl-cncr")

  # Add a horizontal line at y=0
  abline(h=0, col="gray", lty=2)

  # Highlight and label statistically significant probes
  if (!is.null(status)) {
    sig_probes <- which(status < 0.05)  # p-adj < 0.05
    points(avg_expr[sig_probes], lfc[sig_probes], pch=pch, col="red", cex=1)  # Red points with size cex=1

    # Label top 5 significant probes with largest absolute fold changes
    top_sig <- head(sig_probes[order(abs(lfc[sig_probes]), decreasing=TRUE)], 6)
    text(avg_expr[top_sig], lfc[top_sig],
         labels=rownames(fit2)[top_sig], pos=4, cex=0.7, col="red")
  }

  # Add a legend
  if (legend) {
    legend("topright", legend=c("Significant (p-adj < 0.05)", "Not significant"),
           col=c("red", "black"), pch=pch)
  }
}

# Get the adjusted p-values
adj_pvals <- p.adjust(fit2$p.value[,ct], method="BH")
png("MDplot.png", width = 900, height = 800, res = 150)
# Use the custom function
custom_plotMD(fit2, column=ct, status=adj_pvals, legend=TRUE, pch=20, cex=1)
grid()
dev.off()

ex <- exprs(gset)

dev.new(width=3+ncol(gset)/6, height=5)
ord <- order(gs)  # order samples by group
palette(c("#1B9E77", "#7570B3", "#E7298A", "#E6AB02", "#D95F02",
          "#66A61E", "#A6761D", "#B32424", "#B324B3", "#666666"))
par(mar=c(7,4,2,1))
title <- paste ("GSE20437", "/", annotation(gset), sep ="")
boxplot(ex[,ord], boxwex=0.6, notch=T, main=title, outline=FALSE, las=2, col=gs[ord])
legend("topleft", groups, fill=palette(), bty="n")
dev.off()

# expression value distribution
par(mar=c(4,4,2,1))
title <- paste ("GSE199135", "/", annotation(gset), " value distribution", sep ="")
png("valuedistribution.png", width = 900, height = 800, res = 150)
plotDensities(ex, group=gs, main=title, legend ="topright")
dev.off()

install.packages("ggplot2")
install.packages("ggrepel")

# Load necessary libraries
library(umap)
library(ggplot2)
library(ggrepel)

# Data preparation
ex <- na.omit(ex)  # Remove rows with NAs
ex <- ex[!duplicated(ex), ]  # Remove duplicates

# Perform UMAP
ump <- umap(t(ex), n_neighbors = 15, random_state = 123)

# Convert UMAP layout to a data frame for plotting
ump_df <- as.data.frame(ump$layout)
colnames(ump_df) <- c("UMAP1", "UMAP2")
ump_df$Group <- gs  # Ensure gs is defined and corresponds to the groups

# Plot using ggplot2 with ggrepel for non-overlapping labels
ggplot(ump_df, aes(x = UMAP1, y = UMAP2, color = Group)) +
    geom_point(size = 3) +
    geom_text_repel(aes(label = rownames(ump_df)), size = 3) +
    theme_minimal() +
    labs(title = "UMAP plot, nbrs=15") +
    theme(legend.position = "right")

png("cluster.png", width = 900, height = 800, res = 150)

# Data preparation
ex <- na.omit(ex)  # Remove rows with NAs
ex <- ex[!duplicated(ex), ]  # Remove duplicates

# Perform UMAP
ump <- umap(t(ex), n_neighbors = 15, random_state = 123)

# Convert UMAP layout to a data frame for plotting
ump_df <- as.data.frame(ump$layout)
colnames(ump_df) <- c("UMAP1", "UMAP2")
ump_df$Group <- gs  # Ensure gs is defined and corresponds to the groups

# Plot using ggplot2 with ggrepel for non-overlapping labels, and change scale
ggplot(ump_df, aes(x = UMAP1, y = UMAP2, color = Group)) +
    geom_point(size = 3) +
    geom_text_repel(aes(label = rownames(ump_df)), size = 3) +
    theme_minimal() +
    labs(title = "UMAP plot, nbrs=15") +
    theme(legend.position = "right") +
    xlim(-10, 10) +  # Adjust x-axis scale
    ylim(-10, 10)    # Adjust y-axis scale

  dev.off()

# mean-variance trend, helps to see if precision weights are needed
png("Mean variance trend.png", width = 900, height = 800, res = 150)
plotSA(fit2, main="Mean variance trend, GSE199135")
grid()
dev.off()



library(pheatmap)

# Extract top genes
tT <- topTable(fit2, adjust = "fdr", sort.by = "B", number = Inf)
top_genes <- tT[tT$adj.P.Val < 0.05 & abs(tT$logFC) > 1, ]
top_gene_ids <- rownames(top_genes)

# Extract expression data for top genes
exprs_top_genes <- exprs(gset)[top_gene_ids, ]

# Create heatmap
pheatmap(exprs_top_genes,
         show_rownames = TRUE,
         show_colnames = FALSE,
         clustering_distance_rows = "correlation",
         clustering_distance_cols = "correlation",
         clustering_method = "complete",
         main = "Heatmap of Top Differentially Expressed Genes")

# Load the limma package
library(limma)

# Assuming `fit2` is the result of your linear model fit and `gset` is your ExpressionSet

# Step 1: Get the full results table from the linear model fit
tT <- topTable(fit2, adjust = "fdr", sort.by = "B", number = Inf)

# Step 2: Identify top differentially expressed genes based on adjusted p-value and log fold change
top_genes <- tT[tT$adj.P.Val < 0.05 & abs(tT$logFC) > 1, ]

# Step 3: Get the feature data (gene symbols and titles) from the merged ExpressionSet
feat_data <- fData(gset)

# Step 4: Ensure the row names match between top_genes and feat_data
top_genes <- top_genes[rownames(top_genes) %in% rownames(feat_data), ]

# Step 5: Extract gene symbols and titles from the feature data
gene_info <- feat_data[rownames(top_genes), c("Gene.symbol", "Gene.title")]

# Step 6: Combine the gene information with the statistical results
result_table <- cbind(gene_info, top_genes)

# Step 7: Sort the results by adjusted p-value
result_table <- result_table[order(result_table$adj.P.Val), ]

# Step 8: Print the top 69 genes with their symbols, titles, logFC, and adjusted p-values
print(head(result_table[, c("Gene.symbol", "Gene.title", "logFC", "adj.P.Val")], 20))

# Load the limma package
library(limma)

# Assuming `fit2` is the result of your linear model fit and `gset` is your ExpressionSet

# Step 1: Get the full results table from the linear model fit
tT <- topTable(fit2, adjust = "fdr", sort.by = "B", number = Inf)

# Step 2: Get the feature data (gene symbols and titles) from the merged ExpressionSet
feat_data <- fData(gset)

# Step 3: Ensure the row names match between tT and feat_data
tT <- tT[rownames(tT) %in% rownames(feat_data), ]

# Step 4: Extract gene symbols and titles from the feature data
gene_info <- feat_data[rownames(tT), c("Gene.symbol", "Gene.title")]

# Step 5: Combine the gene information with the statistical results
result_table <- cbind(gene_info, tT)

# Step 6: Sort the results by log fold change in descending order
result_table <- result_table[order(-result_table$logFC), ]

# Step 7: Print all the genes sorted by descending logFC
print(result_table[, c("Gene.symbol", "Gene.title", "logFC", "adj.P.Val")])

install.packages("ggbiplot")

install.packages("ggplot2")

library(limma)

# MA plot
plotMA(fit2, main = "MA Plot")
grid()

